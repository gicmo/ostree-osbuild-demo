#!/usr/bin/python3

import argparse
import json
import os
import subprocess
import shutil
import sys

# Hack to ensure with have the osbuild package available
sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                "osbuild"))
import osbuild  #pylint: disable=wrong-import-position


RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[31m"


def genisoimage(outdir, datdir):
    args = [
        "genisoimage",
        "-input-charset", "utf-8",
        "-output", f"{outdir}/cloudinit.iso",
        "-volid", "cidata",
        "-joliet",
        "-rock",
        "-quiet",
        f"{datdir}/user-data",
        f"{datdir}/meta-data"]

    subprocess.run(args, check=True)


def boot(args):
    builddir = "build"
    with open(f"{builddir}/info.json", "r") as f:
        info = json.load(f)

    output_id = info["image"]["output_id"]
    image_name = info["image"]["name"]
    path = f"{builddir}/store/refs/{output_id}/{image_name}"
    print(f"Image at {path}")

    datadir = os.path.abspath("cloud-init")
    genisoimage(builddir, datadir)

    ovmfcode = "/usr/share/OVMF/OVMF_CODE.fd"

    args = ['qemu-system-x86_64',
            "-m", "2048",
            "-drive",
            f"file={ovmfcode},if=pflash,format=raw,unit=0,readonly=on",
            '-enable-kvm',
            "-snapshot",
            f"-cdrom", f"{builddir}/cloudinit.iso",
            "-net", "nic,model=virtio",
            "-net", "user,hostfwd=tcp::2222-:22,hostfwd=tcp::9091-:9090",
            path]
    r = subprocess.run(args, check=False)
    return r.returncode


class BuildError(Exception):
    pass


def remove_path(path):
    def fixperms(p):
        subprocess.run(["chattr", "-i", p],
                       check=False)
        os.chmod(p, 0o700)

    def unlink(p):
        try:
            os.unlink(p)
        except IsADirectoryError:
            remove_path(p)
        except FileNotFoundError:
            pass

    def on_error(_fn, p, exc_info):
        e = exc_info[0]
        if issubclass(e, FileNotFoundError):
            pass
        elif issubclass(e, PermissionError):
            if p != path:
                fixperms(os.path.dirname(p))
            fixperms(p)
            unlink(p)
        else:
            raise e

    shutil.rmtree(path, onerror=on_error)


def store_status(store, object_id):
    if not store:
        return ""

    if not store.contains(object_id):
        return ""

    return " stored"


def print_pipeline(pipeline, store, level=0):
    indent = "  "*level

    if pipeline.build:
        print(f"{indent}build:")
        print_pipeline(pipeline.build, store, level=level+1)

    runner = pipeline.runner
    if runner:
        print(f"{indent}runner:")
        print(f"{indent}  {runner}")

    if pipeline.stages:
        print(f"{indent}stages:")
    for stage in pipeline.stages:
        status = store_status(store, stage.id)
        print(f"{indent}  {stage.name}: \t{stage.id}{status}")

    asm = pipeline.assembler
    if asm:
        status = store_status(store, asm.id)
        print(f"{indent}assembler:")
        print(f"{indent}  {asm.name}: \t{asm.id}{status}")


def find_osbuild_module():
    this_file = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(this_file, "osbuild")


def build_manifest(manifest, store, _args):
    sources = manifest.get("sources", {})
    pipeline = manifest["pipeline"]
    pipeline = osbuild.load(pipeline, sources)

    print("Building the following pipeline:")
    print_pipeline(pipeline, store)

    print("")
    stages = pipeline.stages
    if pipeline.build:
        stages = pipeline.build.stages + stages
    for stage in stages:
        if stage.name == "org.osbuild.rpm":
            print(f"checkpointing rpm stage: {stage.id}")
            stage.checkpoint = True

    libdir = find_osbuild_module()

    r = pipeline.run(store.store,
                     interactive=True,
                     libdir=libdir)

    if not r["success"]:
        raise BuildError

    return r, pipeline


def prepare_commit_manifest():
    with open("manifests/f31-ostree-commit.json", "r") as fp:
        manifest = json.load(fp)
    return manifest


def sign_commit(builddir, info):
    output_id = info["ostree"]["output_id"]
    commit_id = info["ostree"]["commit_id"]
    repo = f"{builddir}/store/refs/{output_id}/repo"
    data = {
        "builddir": builddir,
        "repo": repo,
        "output_id": output_id,
        "commit_id": commit_id,
    }

    print("")
    print(f"{BOLD}Signing commit:{RESET}")

    this_path = os.path.dirname(os.path.abspath(__file__))
    r = subprocess.run([f"{this_path}/sign-commit"],
                       encoding="utf-8",
                       input=json.dumps(data),
                       stdout=subprocess.PIPE,
                       check=False)

    if r.returncode != 0:
        raise RuntimeError("Failed to sign commit")

    print("")
    res = json.loads(r.stdout)

    info["ostree"]["gpg"] = res
    write_info(builddir, info)

    return res


def prepare_sources(store, output_id, commit_id, gpg):
    with open("manifests/f31-ostree-image.json", "r") as fp:
        manifest = json.load(fp)

    obj = store.resolve_ref(output_id)
    url = "file://" + os.path.join(obj, "repo")
    sources = manifest["sources"]

    sources["org.osbuild.ostree"] = {
        "commits": {
            commit_id: {
                "remote": {
                    "uid": commit_id,
                    "url": url,
                    **gpg
                }
            }
        }
    }

    return sources


def prepare_image_pipeline(commit_id):
    with open("manifests/f31-ostree-image.json", "r") as fp:
        manifest = json.load(fp)

    for stage in manifest["pipeline"]["stages"]:
        options = stage.get("options")
        if stage["name"] in ["org.osbuild.selinux"]:
            options = options.get("ostree", {})

        if not options or "commit" not in options:
            continue
        options["commit"] = commit_id
    return manifest


def write_info(builddir, info):
    with open(f"{builddir}/info.json", "w+") as f:
        json.dump(info, f)

def write_manifest(manifest, name, builddir):
    with open(f"{builddir}/{name}-manifest.json", "w+") as f:
        json.dump(manifest, f, indent=2)


def build_commit(builddir, store, info, args):
    manifest = prepare_commit_manifest()
    write_manifest(manifest, "commit", builddir)

    print(f"{BOLD}Building the ostree commit:{RESET}")

    _, pipeline = build_manifest(manifest, store, args)

    output_id = pipeline.output_id

    obj = store.resolve_ref(output_id)
    with open(f"{obj}/compose.json") as fp:
        commit_meta = json.load(fp)
        commit_id = commit_meta["ostree-commit"]

    print("")
    print("Pipeline for ostree commit is done:")
    print("  output id:", output_id)
    print("  commit id:", commit_id)

    info["ostree"].update({
        "output_id": output_id,
        "commit_id": commit_id
    })

    write_info(builddir, info)

    return info


def build_image(builddir, store, info, args):
    commit_id = info["ostree"]["commit_id"]
    output_id = info["ostree"]["output_id"]
    gpg = info["ostree"]["gpg"]

    print(f"{BOLD}Building the image{RESET}")

    manifest = prepare_image_pipeline(commit_id)
    sources = prepare_sources(store, output_id, commit_id, gpg)
    manifest["sources"] = sources

    write_manifest(manifest, "image", builddir)

    _, pipeline = build_manifest(manifest, store, args)

    output_id = pipeline.output_id
    image_name = pipeline.assembler.options["filename"]

    print("")
    print("Pipeline for ostree image is done:")
    print("  output id:", output_id)
    print("      image:", image_name)

    image_abspath = store.resolve_ref(output_id)
    image_relpath = os.path.relpath(image_abspath, os.path.curdir)
    print("")
    print("Image ready at:")
    print(f"  {image_relpath}")

    info["image"] = {
        "output_id": output_id,
        "name": image_name,
    }

    write_info(builddir, info)

    return output_id, image_name


def build(args):
    builddir = os.path.abspath("build")
    os.makedirs(builddir, exist_ok=True)
    uid = int(os.getenv("SUDO_UID", os.getuid()))
    os.chown(builddir, uid, os.getgid())

    store = osbuild.objectstore.ObjectStore(f"{builddir}/store")

    try:
        with open(f"{builddir}/info.json", "r") as f:
            info = json.load(f)
    except FileNotFoundError:
        info = {'ostree': {}}

    target = args.target or ['commit', 'sign', 'image']

    try:
        if 'commit' in target:
            build_commit(builddir, store, info, args)

        if 'sign' in target:
            sign_commit(builddir, info)

        if 'image' in target:
            build_image(builddir, store, info, args)

    except KeyboardInterrupt:
        print()
        print(f"{RESET}{BOLD}{RED}Aborted{RESET}")
        return 130
    except BuildError:
        print()
        print(f"{RESET}{BOLD}{RED}Failed{RESET}")
        return 1
    return 0


def clean(_args):
    path = os.path.abspath("build")
    print(f"About to clean up {path}.")
    try:
        s = input("Type 'Y' to confirm: ")
    except (EOFError, KeyboardInterrupt):
        return 1
    if s != 'Y':
        return 1
    remove_path(path)
    return 0


def main():
    parser = argparse.ArgumentParser(description="osbuild ostree demo")
    parser.set_defaults(cmd=None)
    sp = parser.add_subparsers(help='commands')

    subpar = sp.add_parser("build", help='build commit or image')
    subpar.add_argument("--commit", dest='target', action='append_const', const="commit",
                        help='build the commit')
    subpar.add_argument("--sign", dest='target', action='append_const', const="sign",
                        help='sign the commit')
    subpar.add_argument("--image", dest='target', action='append_const', const="image",
                        help='build the image')
    subpar.set_defaults(cmd='build')

    subpar = sp.add_parser("clean", help='cleanup the build dir')
    subpar.set_defaults(cmd='clean')

    subpar = sp.add_parser("boot", help='boot the final image')
    subpar.set_defaults(cmd='boot')

    args = parser.parse_args()

    if not args.cmd:
        print(f"{RED}Error{RESET}: Need command\n")
        parser.print_help(sys.stderr)
        return 1

    if args.cmd == "build":
        return build(args)
    if args.cmd == "clean":
        return clean(args)
    if args.cmd == "boot":
        return boot(args)
    return 1


if __name__ == "__main__":
    sys.exit(main())
